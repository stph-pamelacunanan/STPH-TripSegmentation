# STPH-TripSegmentation

## Motivation
Unlike the STPH mobile app, the OBD device is unable to identify individual vehicle trips, necessitating the development of a trip segmentation method for more accurate telematics analysis. Additionally, the trip_id generated by the STPH mobile app may be unreliable, as signal interruptions or GPS issues can cause the mobile app to register a new trip even when the vehicle remains on the same journey.

This trip segmentation method was developed in Python, leveraging both temporal and spatial features in the dataset that is common to both the mobile app and telematics datasets. The python notebook `Trip Segmentation.ipynb` creates a local library named `stph_trips` that can be imported thereafter. The module for trip segmentation is named `trip_segmentor`. This library shall be updated to include two other modules that utilizes the output of the `trip_segmentor` module: one module to create the trip super summaries, and another module to compute for the dashboard (Superset) metrics.

## Trip Segmentation Process

### Prework: Refining the GTFS Stops

Prior to the trip segmentation, there is prework done on the GTFS route stops. The `reduce_gps_points()` function is designed to refine the GPS points in the GTFS stops by enforcing minimum and maximum distance constraints between consecutive points. The function ensures that points in the dataset are spaced at least `min_distance` meters apart (default setting is 100). Additionally, if two consecutive points exceed the `max_distance` threshold (default setting is 150), the function interpolates intermediate points between them. This refinement ensures that the resulting GTFS stops dataset remains computationally efficient while still having sufficient point density for accurate nearest stop detection during trip segmentation.
The `reduce_gps_points()` function operates in two main stages: first, it iterates through the original dataset to build an initial list of points that meet the spacing criteria. Afterwards, it performs a second pass to ensure the remaining points strictly adhere to both the `min_distance` and `max_distance` constraints. 

### Segmenting trips

Here is an overview of the trip segmentation process that follows:

**A.  Filter and Order Data** 

* Remove observations where the engine RPM is 0.
* Order the remaining data points chronologically by timestamp.

**B.  Identify Nearest Stops (Inbound Route First)**

* Use the `nearest_stop_checker()` function to determine the closest route stop for each GPS point.
* The default is within a 100-m radius of the GTFS route stop.
* The function takes as input a DataFrame containing the route stops, making it applicable for both inbound and outbound routes.
* Initially, the function is applied only to the inbound route.

**C.  Trip Identification**
* Use the function `sequence_checker()` to detect sequences of non-decreasing stop numbers from the output of Step B.
  * Non-decreasing stop numbers indicate that the vehicle is following the GTFS-defined route in the correct sequence, signifying that it is actively on a trip.
  * To account for minor GPS inaccuracies, which may occasionally result in a recorded point falling outside the radius of any predefined route stops despite the vehicle remaining on its journey, we introduce a tolerance threshold. Specifically, a trip is not immediately considered halted due to a lack of detected stops; instead, a maximum allowable number of consecutive unmatched points is set. By default, this threshold is 60, corresponding to 60 seconds (or 1 minute), given the datasetâ€™s sampling rate of 1 Hz.
* Assign a unique trip identifier based on the trip type (inbound) and timestamp of the first data point in each sequence.

**D.  Trip Filtering and Categorization**
* Group data by the assigned trip identifier.
* Filter out:
  * Extremely short trips.
    * The default setting is to filter out trips less than 15 minutes.
  * Trips where the total distance is less than some percentage < 100 of the expected route distance.
    * The default setting is 70%.
* Identifying cut trips:
  * Trips that do not meet the set percentage threshold of the distance or time but cover more than one kilometer will be labeled as cut trips.
* Append the trip identifier (complete trip) to the original dataset using the timestamp and vehicle code.

**E.  Repeat Stop Matching for Outbound Route**
* Apply nearest_stop_checker() again, this time for the outbound route.
* Skip any data points that already have a trip identifier.

**D.  Repeat Trip Identification and Filtering**
* Execute Steps C to E for the outbound route.

**F.  Return Processed Data**
* Output the original dataset with the appended trip identifiers and labels. This can now be used to generate dashboard metrics as well as trip super summaries.

